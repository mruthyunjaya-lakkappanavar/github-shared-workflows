name: Update Dashboard

on:
  schedule:
    - cron: "0 */6 * * *" # Every 6 hours ‚Äî fallback data freshness
  workflow_dispatch: # Manual trigger
    inputs:
      repo:
        description: "Specific repo to update (blank = all)"
        required: false
        type: string
  repository_dispatch: # Triggered by consumer repos after CI
    types: [dashboard-update]

# ‚îÄ‚îÄ Concurrency ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Serialize all dashboard writes so concurrent pushes never
# create merge conflicts. Runs queue instead of cancelling.
concurrency:
  group: dashboard-data-update
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  update-dashboard:
    name: Update Dashboard Data
    runs-on: ubuntu-latest

    steps:
      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 1

      - name: Determine repos to update
        id: repos
        run: |
          # If triggered by repository_dispatch, update only the triggering repo
          # If triggered manually with a specific repo, update only that one
          # Otherwise, update all repos listed in manifest.json
          SPECIFIC=""
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            SPECIFIC="${{ github.event.client_payload.repo }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            SPECIFIC="${{ inputs.repo }}"
          fi

          if [[ -n "$SPECIFIC" ]]; then
            echo "repos=$SPECIFIC" >> "$GITHUB_OUTPUT"
            echo "mode=single" >> "$GITHUB_OUTPUT"
            echo "üì¶ Updating single repo: $SPECIFIC"
          else
            # Read repo names from manifest.json
            REPOS=$(jq -r '.repos[].name' manifest.json | tr '\n' ' ')
            echo "repos=$REPOS" >> "$GITHUB_OUTPUT"
            echo "mode=all" >> "$GITHUB_OUTPUT"
            echo "üì¶ Updating all repos: $REPOS"
          fi

      - name: Fetch and write per-repo data files
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          OWNER="mruthyunjaya-lakkappanavar"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          DATA_DIR="data"

          mkdir -p "$DATA_DIR"

          for REPO in ${{ steps.repos.outputs.repos }}; do
            echo "‚îÄ‚îÄ Fetching data for $REPO ‚îÄ‚îÄ"

            # Each repo gets its own JSON file ‚Üí no cross-repo conflicts
            RUNS=$(curl -s -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/$OWNER/$REPO/actions/runs?per_page=20&status=completed" \
              | jq --arg repo "$REPO" --arg ts "$TIMESTAMP" '{
                  repo: $repo,
                  updated_at: $ts,
                  runs: [.workflow_runs[:20] | .[] | {
                    id: .id,
                    name: .name,
                    workflow_name: .name,
                    status: .status,
                    conclusion: .conclusion,
                    head_branch: .head_branch,
                    head_sha: .head_sha,
                    event: .event,
                    created_at: .created_at,
                    updated_at: .updated_at,
                    run_started_at: .run_started_at,
                    html_url: .html_url,
                    run_number: .run_number,
                    actor: {
                      login: .actor.login,
                      avatar_url: .actor.avatar_url
                    }
                  }]
                }')

            echo "$RUNS" > "$DATA_DIR/$REPO.json"

            COUNT=$(echo "$RUNS" | jq '.runs | length')
            echo "  ‚úÖ Wrote $COUNT runs to $DATA_DIR/$REPO.json"
          done

          echo "‚úÖ Dashboard data updated at $TIMESTAMP"

      - name: Commit and push (with retry for conflicts)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data/

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Retry loop handles the rare case where a queued run
          # pushes between our fetch and our push
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            git commit -m "chore: update dashboard data [skip ci]"
            if git push; then
              echo "‚úÖ Push succeeded on attempt $i"
              exit 0
            fi

            echo "‚ö†Ô∏è  Push failed (attempt $i/$MAX_RETRIES), rebasing..."
            git pull --rebase
          done

          echo "‚ùå Push failed after $MAX_RETRIES attempts"
          exit 1
