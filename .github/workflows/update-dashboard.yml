name: Update Dashboard

on:
  schedule:
    - cron: "0 */6 * * *" # Every 6 hours ‚Äî fallback data freshness
  workflow_dispatch: # Manual trigger
    inputs:
      repo:
        description: "Specific repo to update (blank = all)"
        required: false
        type: string
  repository_dispatch: # Triggered by consumer repos after CI
    types: [dashboard-update]

# ‚îÄ‚îÄ Concurrency ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Serialize all dashboard writes so concurrent pushes never
# create merge conflicts. Runs queue instead of cancelling.
concurrency:
  group: dashboard-data-update
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  update-dashboard:
    name: Update Dashboard Data
    runs-on: ubuntu-latest

    steps:
      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 1

      - name: Determine repos to update
        id: repos
        run: |
          # If triggered by repository_dispatch, update only the triggering repo
          # If triggered manually with a specific repo, update only that one
          # Otherwise, update all repos listed in manifest.json
          SPECIFIC=""
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            SPECIFIC="${{ github.event.client_payload.repo }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            SPECIFIC="${{ inputs.repo }}"
          fi

          if [[ -n "$SPECIFIC" ]]; then
            echo "repos=$SPECIFIC" >> "$GITHUB_OUTPUT"
            echo "mode=single" >> "$GITHUB_OUTPUT"
            echo "üì¶ Updating single repo: $SPECIFIC"
          else
            # Read repo names from manifest.json
            REPOS=$(jq -r '.repos[].name' manifest.json | tr '\n' ' ')
            echo "repos=$REPOS" >> "$GITHUB_OUTPUT"
            echo "mode=all" >> "$GITHUB_OUTPUT"
            echo "üì¶ Updating all repos: $REPOS"
          fi

      - name: Fetch and write per-repo data files
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          OWNER="mruthyunjaya-lakkappanavar"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          DATA_DIR="data"

          mkdir -p "$DATA_DIR"

          for REPO in ${{ steps.repos.outputs.repos }}; do
            echo "‚ïê‚ïê Fetching data for $REPO ‚ïê‚ïê"

            # 1. Fetch workflow runs (filtered, max 20)
            RUNS_RAW=$(curl -sf -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/$OWNER/$REPO/actions/runs?per_page=20" \
              || echo '{"workflow_runs":[]}')

            RUNS=$(echo "$RUNS_RAW" | jq '[.workflow_runs[] | select(
              (.name // "" | ascii_downcase | contains("copilot") | not) and
              (.event != "dynamic")
            ) | {
              id,
              name: (.name // .workflow_name // "unknown"),
              status,
              conclusion,
              html_url,
              created_at,
              updated_at,
              head_branch,
              head_sha,
              event,
              run_number,
              run_started_at: (.run_started_at // .created_at),
              actor: (.actor // .triggering_actor // null | if . then {login: .login, avatar_url: .avatar_url} else null end)
            }]')

            RUN_COUNT=$(echo "$RUNS" | jq 'length')
            echo "  Found $RUN_COUNT runs (filtered)"

            # 2. Fetch jobs for latest 3 CI runs (non-release)
            CI_RUN_IDS=$(echo "$RUNS" | jq -r '[.[] | select(.name | ascii_downcase | contains("release") | not)] | .[0:3] | .[].id')
            ALL_JOBS="[]"

            for RUN_ID in $CI_RUN_IDS; do
              echo "  Fetching jobs for run $RUN_ID..."
              JOBS_RAW=$(curl -sf -H "Authorization: token $GH_TOKEN" \
                "https://api.github.com/repos/$OWNER/$REPO/actions/runs/$RUN_ID/jobs" \
                || echo '{"jobs":[]}')

              PARENT_RUN=$(echo "$RUNS" | jq --arg rid "$RUN_ID" '.[] | select(.id == ($rid | tonumber))')
              PARENT_BRANCH=$(echo "$PARENT_RUN" | jq -r '.head_branch // "main"')
              PARENT_NUMBER=$(echo "$PARENT_RUN" | jq -r '.run_number // 0')
              PARENT_EVENT=$(echo "$PARENT_RUN" | jq -r '.event // "push"')
              PARENT_ACTOR=$(echo "$PARENT_RUN" | jq '.actor // null')

              JOBS=$(echo "$JOBS_RAW" | jq --arg rid "$RUN_ID" --arg branch "$PARENT_BRANCH" \
                --arg num "$PARENT_NUMBER" --arg evt "$PARENT_EVENT" --argjson actor "$PARENT_ACTOR" \
                '[.jobs[] | {
                  id,
                  name: (.name // "unknown"),
                  status,
                  conclusion,
                  html_url,
                  started_at,
                  completed_at,
                  run_id: ($rid | tonumber),
                  run_number: ($num | tonumber),
                  head_branch: $branch,
                  event: $evt,
                  actor: $actor
                }]')

              ALL_JOBS=$(echo "$ALL_JOBS" "$JOBS" | jq -s '.[0] + .[1]')
            done

            JOB_COUNT=$(echo "$ALL_JOBS" | jq 'length')
            echo "  Total jobs collected: $JOB_COUNT"

            # 3. Fetch annotations for latest CI run to get lint/test/security stats
            CI_STATS='{"lint":{},"test":{},"security":{}}'
            LATEST_CI_RUN_ID=$(echo "$RUNS" | jq -r '[.[] | select(.name | ascii_downcase | contains("release") | not)] | .[0].id // empty')

            if [ -n "$LATEST_CI_RUN_ID" ]; then
              echo "  Fetching annotations for latest CI run $LATEST_CI_RUN_ID..."
              LATEST_JOBS_RAW=$(curl -sf -H "Authorization: token $GH_TOKEN" \
                "https://api.github.com/repos/$OWNER/$REPO/actions/runs/$LATEST_CI_RUN_ID/jobs" \
                || echo '{"jobs":[]}')
              LATEST_JOB_IDS=$(echo "$LATEST_JOBS_RAW" | jq -r '.jobs[].id')

              for JOB_ID in $LATEST_JOB_IDS; do
                ANNOTATIONS=$(curl -sf -H "Authorization: token $GH_TOKEN" \
                  "https://api.github.com/repos/$OWNER/$REPO/check-runs/$JOB_ID/annotations" \
                  || echo '[]')
                ANN_COUNT=$(echo "$ANNOTATIONS" | jq 'length')
                if [ "$ANN_COUNT" -gt 0 ]; then
                  for ANN_TITLE in ci_lint ci_test ci_security; do
                    MSG=$(echo "$ANNOTATIONS" | jq -r --arg t "$ANN_TITLE" '.[] | select(.title == $t) | .message // empty')
                    if [ -n "$MSG" ]; then
                      echo "    Found $ANN_TITLE: $MSG"
                      PARSED=$(echo "$MSG" | awk -F'|' '{
                        printf "{"
                        for(i=1;i<=NF;i++){
                          split($i,kv,"=")
                          gsub(/^[[:space:]]+|[[:space:]]+$/, "", kv[1])
                          gsub(/^[[:space:]]+|[[:space:]]+$/, "", kv[2])
                          if(i>1) printf ","
                          printf "\"%s\":\"%s\"", kv[1], kv[2]
                        }
                        printf "}"
                      }')
                      STAT_KEY=$(echo "$ANN_TITLE" | sed 's/ci_//')
                      CI_STATS=$(echo "$CI_STATS" | jq --arg key "$STAT_KEY" --argjson val "$PARSED" '.[$key] = $val')
                    fi
                  done
                fi
              done
            fi

            # 4. Write the complete repo data file
            jq -n \
              --argjson runs "$RUNS" \
              --argjson jobs "$ALL_JOBS" \
              --argjson ciStats "$CI_STATS" \
              --arg generated "$TIMESTAMP" \
              '{
                generated_at: $generated,
                runs: $runs,
                jobs: $jobs,
                ciStats: $ciStats
              }' > "$DATA_DIR/$REPO.json"

            echo "  ‚úÖ Wrote $DATA_DIR/$REPO.json ($(wc -c < "$DATA_DIR/$REPO.json" | tr -d ' ') bytes)"
          done

          # 5. Generate combined dashboard-data.json
          echo "Generating combined dashboard-data.json..."
          jq -n --arg generated "$TIMESTAMP" '{ generated_at: $generated, repos: {} }' > "$DATA_DIR/dashboard-data.json"

          REPOS_LIST=$(jq -r '.repos[].name' manifest.json)
          for REPO in $REPOS_LIST; do
            if [ -f "$DATA_DIR/$REPO.json" ]; then
              COMBINED_TMP=$(mktemp)
              jq --arg repo "$REPO" --slurpfile data "$DATA_DIR/$REPO.json" '.repos[$repo] = $data[0]' "$DATA_DIR/dashboard-data.json" > "$COMBINED_TMP"
              mv "$COMBINED_TMP" "$DATA_DIR/dashboard-data.json"
            fi
          done

          echo "‚úÖ Combined dashboard-data.json ($(wc -c < "$DATA_DIR/dashboard-data.json" | tr -d ' ') bytes)"
          echo "‚úÖ Dashboard data updated at $TIMESTAMP"

      - name: Commit and push (with retry for conflicts)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data/ dashboard/data/

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Retry loop handles the rare case where a queued run
          # pushes between our fetch and our push
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            git commit -m "chore: update dashboard data [skip ci]"
            if git push; then
              echo "‚úÖ Push succeeded on attempt $i"
              exit 0
            fi

            echo "‚ö†Ô∏è  Push failed (attempt $i/$MAX_RETRIES), rebasing..."
            git pull --rebase
          done

          echo "‚ùå Push failed after $MAX_RETRIES attempts"
          exit 1
